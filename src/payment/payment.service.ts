import { HttpException, HttpStatus, Injectable } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import axios from 'axios'
import { PaymeError, TransactionState } from 'src/constants/payme.constants'
import { PrismaService } from 'src/prisma.service'

@Injectable()
export class PaymeService {
	private readonly PAYME_KEY: string
	private readonly PAYME_MERCHANT_ID: string
	private readonly PAYME_BASE_URL: string

	constructor(
		private configService: ConfigService,
		private readonly prisma: PrismaService
	) {
		this.PAYME_KEY = this.configService.get<string>('PAYME_SECRET_KEY_TEST')
		this.PAYME_MERCHANT_ID = this.configService.get<string>('PAYME_MERCHANT_ID')
		this.PAYME_BASE_URL = 'https://test.paycom.uz'
	}

	/**
	 * üìå –°–æ–∑–¥–∞–Ω–∏–µ —á–µ–∫–∞ —á–µ—Ä–µ–∑ API Payme
	 */
	async createReceipt(orderId: string, amount: number, description?: string) {
		try {
			const payload = {
				id: Date.now().toString(),
				method: 'receipts.create',
				params: {
					amount,
					account: { order_id: orderId },
					description: description || '–û–ø–ª–∞—Ç–∞ —à—Ç—Ä–∞—Ñ–∞',
					detail: {
						receipt_type: 0,
						items: [
							{
								title: '–û–ø–ª–∞—Ç–∞ —à—Ç—Ä–∞—Ñ–∞',
								price: amount,
								count: 1,
								code: '00702001001000001',
								package_code: '123456',
								vat_percent: 15
							}
						]
					}
				}
			}

			const xAuth = `${'5e730e8e0b852a417aa49ceb'.trim()}:${'ZPDODSiTYKuX0jyO7Kl2to4rQbNwG08jbghj'.trim()}`

			console.log('üîπ PAYME_AUTH:', xAuth)
			console.log('üîπ PAYME_PAYLOAD:', JSON.stringify(payload, null, 2))

			const response = await axios.post(
				`https://checkout.test.paycom.uz/api`, // ‚úÖ –£–±—Ä–∞–ª `/api`
				payload,
				{
					headers: {
						'Content-Type': 'application/json',
						'X-Auth': xAuth
					}
				}
			)
			return response.data
		} catch (error) {
			console.error(
				'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —á–µ–∫–∞ –≤ Payme:',
				error.response?.data || error
			)
			throw new HttpException(
				`–û—à–∏–±–∫–∞ Payme: ${error.response?.data?.error?.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`,
				HttpStatus.BAD_REQUEST
			)
		}
	}

	/**
	 * üìå –û—Ç–ø—Ä–∞–≤–∫–∞ —á–µ–∫–∞ —á–µ—Ä–µ–∑ API Payme
	 */
	async sendReceipt(receiptId: string, phone: string, description: string) {
		try {
			const payload = {
				id: Date.now().toString(),
				method: 'receipts.send',
				params: {
					id: receiptId,
					phone,
					description
				}
			}

			const xAuth = `${'5e730e8e0b852a417aa49ceb'.trim()}:${'ZPDODSiTYKuX0jyO7Kl2to4rQbNwG08jbghj'.trim()}`

			console.log('üîπ PAYME_AUTH:', xAuth)
			console.log('üîπ PAYME_PAYLOAD:', JSON.stringify(payload, null, 2))

			const response = await axios.post(
				`https://checkout.test.paycom.uz/api`, // ‚úÖ –£–±—Ä–∞–ª `/api`
				payload,
				{
					headers: {
						'Content-Type': 'application/json',
						'X-Auth': xAuth
					}
				}
			)

			return response.data
		} catch (error) {
			console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —á–µ–∫–∞ –≤ Payme:', error)
			throw new HttpException(
				`–û—à–∏–±–∫–∞ Payme: ${error.response?.data?.error?.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`,
				HttpStatus.BAD_REQUEST
			)
		}
	}

	/**
	 * üìå –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
	 */
	async checkPerformTransaction(params: any, id: number) {
		const { account, amount } = params

		const fine = await this.prisma.fine.findUnique({
			where: { id: account.order_id }
		})

		if (!fine) {
			throw new HttpException(PaymeError.ProductNotFound, HttpStatus.NOT_FOUND)
		}

		if (fine.amount !== amount) {
			throw new HttpException(PaymeError.InvalidAmount, HttpStatus.BAD_REQUEST)
		}

		return { jsonrpc: '2.0', result: { allow: true }, id }
	}

	/**
	 * üìå –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
	 */
	async checkTransaction(params: any) {
		console.log('üîπ CheckTransaction –≤—ã–∑–≤–∞–Ω:', params)

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è
		const transaction = await this.findTransactionById(params.id)

		if (!transaction.transactionId) {
			return {
				jsonrpc: '2.0',
				error: {
					code: -31003,
					message: {
						uz: 'Tranzaktsiya topilmadi',
						ru: '–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
						en: 'Transaction not found'
					}
				},
				id: params.id
			}
		}

		// –§–æ—Ä–º–∏—Ä—É–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç
		return {
			jsonrpc: '2.0',
			id: params.id,
			result: {
				create_time: transaction.createdAt,
				perform_time: transaction.performTime,
				cancel_time: transaction.cancelTime,
				transaction: transaction.transactionId,
				state: transaction.status === 'success' ? 2 : 1, // 2 - –æ–ø–ª–∞—á–µ–Ω–æ, 1 - –æ–∂–∏–¥–∞–µ—Ç
				reason: transaction.reason
			}
		}
	}

	/**
	 * üìå –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
	 */
	async createTransaction(params: any, requestId: number) {
		console.log('üîπ CreateTransaction –≤—ã–∑–≤–∞–Ω:', params)

		const { id: transactionId, time: createTime, amount, account } = params

		console.log('transactionIDDD', transactionId)

		if (!account || !account.order_id) {
			return {
				jsonrpc: '2.0',
				id: requestId, // ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º ID –∑–∞–ø—Ä–æ—Å–∞
				error: {
					code: -31050,
					message: {
						uz: 'Buyurtma identifikatori topilmadi',
						ru: '–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–∫–∞–∑–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω',
						en: 'Order ID not found'
					}
				}
			}
		}

		const orderId = account.order_id

		// üîé –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —à—Ç—Ä–∞—Ñ (—Å—á–µ—Ç –ø–ª–∞—Ç–µ–ª—å—â–∏–∫–∞)
		const fine = await this.prisma.fine.findUnique({
			where: { id: orderId }
		})

		if (!fine) {
			return {
				jsonrpc: '2.0',
				id: requestId, // ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º ID –∑–∞–ø—Ä–æ—Å–∞
				error: {
					code: -31050,
					message: {
						uz: 'Buyurtma topilmadi',
						ru: '–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω',
						en: 'Order not found'
					}
				}
			}
		}

		// üí∞ –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–≤–ø–∞–¥–∞–µ—Ç –ª–∏ —Å—É–º–º–∞ –ø–ª–∞—Ç–µ–∂–∞
		if (fine.amount !== amount) {
			return {
				jsonrpc: '2.0',
				id: requestId, // ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º ID –∑–∞–ø—Ä–æ—Å–∞
				error: {
					code: -31001,
					message: {
						uz: 'To‚Äòlov summasi noto‚Äòg‚Äòri',
						ru: '–ù–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞ –ø–ª–∞—Ç–µ–∂–∞',
						en: 'Invalid payment amount'
					}
				}
			}
		}

		const validCreateTime = Number.isInteger(createTime)
			? new Date(createTime)
			: new Date()

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ `validCreateTime` –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –¥–∞—Ç–æ–π
		if (isNaN(validCreateTime.getTime())) {
			return {
				jsonrpc: '2.0',
				id: requestId,
				error: {
					code: -31008,
					message: {
						uz: 'Noto‚Äòg‚Äòri tranzaksiya vaqti',
						ru: '–ù–µ–≤–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏',
						en: 'Invalid transaction time'
					}
				}
			}
		}

		// üîé –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –¥–ª—è —ç—Ç–æ–≥–æ –∑–∞–∫–∞–∑–∞
		const existingTransaction = await this.prisma.payment.findFirst({
			where: { fineId: orderId }
		})

		if (existingTransaction) {
			if (existingTransaction.transactionId === transactionId) {
				// ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
				return {
					jsonrpc: '2.0',
					id: requestId, // ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º ID –∑–∞–ø—Ä–æ—Å–∞
					result: {
						transaction: existingTransaction.transactionId,
						create_time: existingTransaction.createdAt.getTime(),
						state: TransactionState.Pending // –û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–ª–∞—Ç—ã
					}
				}
			}

			// ‚ùå –û—à–∏–±–∫–∞: –ø–æ–≤—Ç–æ—Ä–Ω–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —Å –¥—Ä—É–≥–∏–º ID
			return {
				jsonrpc: '2.0',
				id: requestId, // ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º ID –∑–∞–ø—Ä–æ—Å–∞
				error: {
					code: -31050,
					message: {
						uz: 'Tranzaksiya allaqachon mavjud, boshqa ID bilan qaytadan yaratib bo‚Äòlmaydi',
						ru: '–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ —Å –¥—Ä—É–≥–∏–º ID –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ',
						en: 'Transaction already exists, cannot recreate with a different ID'
					}
				}
			}
		}

		// ‚úÖ –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
		const newTransaction = await this.prisma.payment.create({
			data: {
				fineId: orderId,
				method: 'payme',
				status: 'pending',
				createdAt: validCreateTime,
				amount: fine.amount,
				transactionId
			}
		})

		console.log(
			`‚úÖ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è ${newTransaction.transactionId} —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!`
		)

		// üîÑ –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –æ—Ç–º–µ–Ω—ã –ø–æ —Ç–∞–π–º–∞—É—Ç—É (12 —á–∞—Å–æ–≤ = 43 200 000 –º—Å)
		setTimeout(async () => {
			const transaction = await this.prisma.payment.findUnique({
				where: { transactionId }
			})

			if (transaction && transaction.status === 'pending') {
				await this.prisma.payment.update({
					where: { transactionId },
					data: {
						status: 'failed',
						cancelTime: new Date(),
						reason: '4' // –û—Ç–º–µ–Ω–∞ –ø–æ —Ç–∞–π–º–∞—É—Ç—É
					}
				})

				await this.prisma.fine.update({
					where: { id: orderId },
					data: { status: 'pending' } // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞—Ç—É—Å "–æ–∂–∏–¥–∞–Ω–∏–µ –æ–ø–ª–∞—Ç—ã"
				})

				console.log(`‚ùå –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è ${transactionId} –æ—Ç–º–µ–Ω–µ–Ω–∞ –ø–æ —Ç–∞–π–º–∞—É—Ç—É.`)
			}
		}, 43200000) // 12 —á–∞—Å–æ–≤

		// ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
		return {
			jsonrpc: '2.0',
			id: requestId, // ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º ID –∑–∞–ø—Ä–æ—Å–∞
			result: {
				transaction: newTransaction.transactionId,
				create_time: newTransaction.createdAt.getTime(),
				state: TransactionState.Pending // –û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–ª–∞—Ç—ã
			}
		}
	}

	/**
	 * üìå –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞
	 */
	async performTransaction(params: any, id: number) {
		console.log('üîπ PerformTransaction –≤—ã–∑–≤–∞–Ω:', params)

		const transaction = await this.prisma.payment.findUnique({
			where: { transactionId: params.id },
			include: { fine: true }
		})

		if (!transaction) {
			throw new HttpException(
				PaymeError.TransactionNotFound,
				HttpStatus.NOT_FOUND
			)
		}

		if (transaction.status !== 'pending') {
			if (transaction.status === 'success') {
				return {
					jsonrpc: '2.0',
					id: params.id,
					result: {
						perform_time: transaction.performTime
							? transaction.performTime.getTime()
							: 0,
						transaction: transaction.transactionId,
						state: TransactionState.Paid
					}
				}
			}
			throw new HttpException(
				PaymeError.CantDoOperation,
				HttpStatus.BAD_REQUEST
			)
		}

		const performTime = new Date()

		await this.prisma.payment.update({
			where: { transactionId: params.id },
			data: { status: 'success', performTime } // ‚úÖ –ó–∞–ø–∏—Å—ã–≤–∞–µ–º `performTime`
		})

		await this.prisma.fine.update({
			where: { id: transaction.fine.id },
			data: { status: 'paid' }
		})

		return {
			jsonrpc: '2.0',
			id: params.id,
			result: {
				perform_time: performTime.getTime(),
				transaction: transaction.transactionId,
				state: TransactionState.Paid
			}
		}
	}

	/**
	 * üìå –û—Ç–º–µ–Ω–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
	 */
	async cancelTransaction(params: any, id: number) {
		console.log('üîπ CancelTransaction –≤—ã–∑–≤–∞–Ω:', params)

		const transaction = await this.prisma.payment.findUnique({
			where: { transactionId: params.id },
			include: { fine: true }
		})

		if (!transaction) {
			throw new HttpException(
				PaymeError.TransactionNotFound,
				HttpStatus.NOT_FOUND
			)
		}

		const cancelTime = new Date()

		await this.prisma.payment.update({
			where: { transactionId: params.id },
			data: {
				status: 'failed',
				cancelTime, // ‚úÖ –ó–∞–ø–∏—Å—ã–≤–∞–µ–º `cancelTime`
				reason: params.reason ? String(params.reason) : null // ‚úÖ –ó–∞–ø–∏—Å—ã–≤–∞–µ–º `reason`
			}
		})

		await this.prisma.fine.update({
			where: { id: transaction.fine.id },
			data: { status: 'deleted' }
		})

		return {
			jsonrpc: '2.0',
			id: params.id,
			result: {
				transaction: transaction.transactionId,
				cancel_time: cancelTime.getTime(),
				state: TransactionState.PendingCanceled,
				reason: params.reason ? String(params.reason) : null
			}
		}
	}

	/**
	 * üìå –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
	 */
	/**
	 * üìå –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—ã–ø–∏—Å–∫–∏ –ø–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥
	 */
	async getStatement(params: { from: number; to: number }) {
		console.log('üîπ getStatement –≤—ã–∑–≤–∞–Ω:', params)

		const { from, to } = params

		// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º timestamps –≤ Date
		const fromDate = new Date(from)
		const toDate = new Date(to)

		// –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∑–∞ –ø–µ—Ä–∏–æ–¥
		const transactions = await this.prisma.payment.findMany({
			where: {
				createdAt: {
					gte: fromDate,
					lte: toDate
				}
			},
			include: {
				fine: true // –ü–æ–¥–≥—Ä—É–∂–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —à—Ç—Ä–∞—Ñ–µ
			}
		})

		// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –Ω—É–∂–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
		return {
			jsonrpc: '2.0',
			result: transactions.map(transaction => ({
				id: transaction.transactionId,
				time: transaction.createdAt.getTime(),
				amount: transaction.amount,
				account: {
					order_id: transaction.fineId // ID –∑–∞–∫–∞–∑–∞
				},
				create_time: transaction.createdAt.getTime(),
				perform_time: transaction.performTime
					? transaction.performTime.getTime()
					: 0,
				cancel_time: transaction.cancelTime
					? transaction.cancelTime.getTime()
					: 0,
				transaction: transaction.transactionId,
				state: transaction.status,
				reason: transaction.reason || null
			}))
		}
	}

	/**
	 * üìå –ü–æ–∏—Å–∫ –∑–∞–∫–∞–∑–∞ (—à—Ç—Ä–∞—Ñ–∞) –ø–æ `order_id`
	 */
	async findOrderById(orderId: string) {
		console.log('üîπ findOrderById –≤—ã–∑–≤–∞–Ω:', orderId)

		const fine = await this.prisma.fine.findUnique({
			where: { id: orderId }
		})

		if (!fine) return null

		return {
			id: fine.id,
			amount: fine.amount,
			status: fine.status
		}
	}

	async findTransactionById(transactionId: string) {
		console.log(`üîπ –ü–æ–∏—Å–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø–æ ID: ${transactionId}`)

		const transaction = await this.prisma.payment.findUnique({
			where: { transactionId }
		})

		if (!transaction) {
			console.log(`‚ùå –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —Å ID ${transactionId} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞`)
			return null
		}

		console.log(`‚úÖ –ù–∞–π–¥–µ–Ω–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è:`, transaction)

		const state =
			transaction.status === 'success'
				? 2
				: transaction.status === 'failed'
					? -1
					: 1

		return {
			id: transaction.id,
			transactionId: transaction.transactionId,
			fineId: transaction.fineId,
			status: transaction.status,
			createdAt: transaction.createdAt.getTime(), // Timestamp –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
			performTime: transaction.performTime
				? transaction.performTime.getTime()
				: 0,
			cancelTime: transaction.cancelTime ? transaction.cancelTime.getTime() : 0,
			reason: transaction.reason || null,
			state
		}
	}
}
